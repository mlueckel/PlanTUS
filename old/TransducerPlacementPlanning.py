#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Sep 16 14:46:30 2023

@author: Maximilian Lueckel, mlueckel@uni-mainz.de
"""
#=============================================================================
#=============================================================================
# Generate and visualize useful metrics for planning of TUS transducer
# placement
#=============================================================================
#=============================================================================
# Input:
# - T1 image (same as used for SimNIBS' charm)
# - Head mesh (.msh file) generated by SimNIBS' charm pipeline
# - Mask (.nii/.nii.gz file) of target region of interest (in same space as T1
#   image used for SimNIBS' charm)
# - Maximum focal depth of TUS transducer (in mm)
# - Maximum allowed angle for tilting of TUS transducer (in degree)
#-----------------------------------------------------------------------------
# Outputs:
# - 3D head and skull model (in surf.gii .stl formats)
# - Metric files (func.gii format)
#=============================================================================
#=============================================================================
# Requirements:
# Python
# - numpy
# - scipy
# - math
# - nibabel
# - nilearn
# - simnibs
# - vtk
# SimNIBS (incl. simnibs_python)
# Conenctome Workbench
# Freesurfer
# FSL
#=============================================================================
# Specify variables
#=============================================================================

# Path to T1 image (used for SimNIBS' charm)
t1_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/T1.nii.gz'

# Path to head mesh (.msh file) generated by SimNIBS' charm
simnibs_mesh_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max.msh'

# Name of and path to mask of target region of interest (in same space as T1
# image)
#target_roi_name = 'NAcc'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftAccumbens.nii.gz'
#target_roi_name = 'vmPFC'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-cortical_prob_FrontalMedialCortex.nii.gz'
#target_roi_name = 'sgACC'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-cortical_prob_SubcallosalCortex.nii.gz'
#target_roi_name = 'Thalamus'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftThalamus.nii.gz'
#target_roi_name = 'Amygdala'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftAmygdala.nii.gz'
#target_roi_name = 'BF'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_JulichBrain_MPMAtlas_CH4_l_icbm.nii'
#target_roi_name = 'Putamen'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftPutamen.nii.gz'
#target_roi_name = "Hippocampus"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftHippocampus.nii.gz"
#target_roi_name = "Thalamus_MedialDorsalNucleus_right"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_talairach_Right_Thalamus_Medial_Dorsal_Nucleus.nii.gz"
#target_roi_name = "Thalamus_NucleusReticulatusPolaris_bilateral"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_histthal_Nucleus_Reticulatus_Polaris.nii.gz"
#target_roi_name = "Thalamus_AnteriorNucleus_right"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_talairach_Right_Thalamus_Anterior_Nucleus.nii.gz"
target_roi_name = "LateralVentricle_right"
target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford_subcortical_prob_Right_Lateral_Ventricle.nii.gz"
#target_roi_name = "Thalamus_MedialDorsalNucleus_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/sub-Max_talairach_Left_Thalamus_Medial_Dorsal_Nucleus.nii.gz"
#target_roi_name = "Thalamus_AnteriorNucleus_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/sub-Max_talairach_Left_Thalamus_Ventral_Anterior_Nucleus.nii.gz"
#target_roi_name = "LateralVentricle_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/sub-Max_harvardoxford_subcortical_prob_Left_Lateral_Ventricle.nii.gz"



# Maximum focal depth of transducer (in mm)
# Note: Set to 1000 if you want a "whole-head" map of distances
max_distance = 76.6 # note: max. focal depth of CTX-500

# Maximum allowed angle for tilting of TUS transducer (in degree)
# Note: Set to 360 if you want a "whole-head" map of angles
max_angle = 10 #10

scene_template_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_PathOptimization/TUSTransducerPlacementPlanning_TEMPLATE.scene'


#=============================================================================
# Load required python packages
#=============================================================================
import os
import glob
import numpy as np
from scipy.cluster.vq import kmeans, vq
import math
import nibabel as nib
from nilearn import image, plotting, surface
from simnibs import mesh_io
import vtk
import csv
import pandas as pd
import shutil
#=============================================================================
# Get relevant paths
#=============================================================================
simnibs_mesh_path = os.path.split(simnibs_mesh_filepath)[0]
target_roi_path = os.path.split(target_roi_filepath)[0]
target_roi_filename = os.path.split(target_roi_filepath)[1]
#=============================================================================
# Convert SimNIBS mesh(es) to surface file(s)
#=============================================================================

### Load SimNIBS mesh
simnibs_mesh = mesh_io.read_msh(simnibs_mesh_filepath)

### Get tissue-specific meshes
# Skin
simnibs_mesh_skin = simnibs_mesh.crop_mesh(tags=1005)

# Skull
simnibs_mesh_skull = simnibs_mesh.crop_mesh(tags=[1007,1008]) # 1007 = compact bone, 1008 = spongy bone

### Save tissue-specific meshes as freesurfer surface file
# Skin
mesh_io.write_freesurfer_surface(simnibs_mesh_skin, simnibs_mesh_path + "/skin_freesurfer")

# Skull
mesh_io.write_freesurfer_surface(simnibs_mesh_skull, simnibs_mesh_path + "/skull_freesurfer")

### Convert to stl and surf.gii files
# Skin
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skin_freesurfer" + " " +
          simnibs_mesh_path + "/skin.stl")

os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skin_freesurfer" + " " +
          simnibs_mesh_path + "/skin.surf.gii")

# Skull
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skull_freesurfer" + " " +
          simnibs_mesh_path + "/skull.stl")
          
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skull_freesurfer" + " " +
          simnibs_mesh_path + "/skull.surf.gii")

### Remove intermediate files
os.remove(simnibs_mesh_path + "/skin_freesurfer")
os.remove(simnibs_mesh_path + "/skull_freesurfer")


#==============================================================================
# Get metrics from surfaces
#==============================================================================

### vertex coordinates
# Skin
os.system('wb_command -surface-coordinates-to-metric ' +
           simnibs_mesh_path + "/skin.surf.gii" + ' ' +
           simnibs_mesh_path + "/skin_coordinates.func.gii")

skin_coordinates = surface.load_surf_data(simnibs_mesh_path + "/skin_coordinates.func.gii")
skin_coordinates = np.array(skin_coordinates, dtype=float)

# Skull
os.system('wb_command -surface-coordinates-to-metric ' +
           simnibs_mesh_path + "/skull.surf.gii" + ' ' +
           simnibs_mesh_path + "/skull_coordinates.func.gii")

skull_coordinates = surface.load_surf_data(simnibs_mesh_path + "/skull_coordinates.func.gii")
skull_coordinates = np.array(skull_coordinates, dtype=float)



### surface/vertex normals
# Skin
os.system('wb_command -surface-normals ' +
           simnibs_mesh_path + "/skin.surf.gii" + ' ' +
           simnibs_mesh_path + "/skin_normals.func.gii")

skin_normals = surface.load_surf_data(simnibs_mesh_path + "/skin_normals.func.gii")
skin_normals = np.array(skin_normals, dtype=float)

# Skull
os.system('wb_command -surface-normals ' +
           simnibs_mesh_path + "/skull.surf.gii" + ' ' +
           simnibs_mesh_path + "/skull_normals.func.gii")

skull_normals = surface.load_surf_data(simnibs_mesh_path + "/skull_normals.func.gii")
skull_normals = np.array(skull_normals, dtype=float)

#==============================================================================
# Create dummy metric and nifti file
#==============================================================================

# create dummy metric file (mean of vertex coordiantes)
os.system("wb_command -metric-reduce " +
          simnibs_mesh_path + "/skin_coordinates.func.gii" + " " +
          "MEAN " + 
          simnibs_mesh_path + "/skin_coordinates_MEAN.func.gii")

# convert dummy metric file to dummy nifti file
os.system("wb_command -metric-convert -to-nifti " +
          simnibs_mesh_path + "/skin_coordinates_MEAN.func.gii" + " " +
          simnibs_mesh_path + "/skin_coordinates_MEAN.nii.gz")

# load dummy nifti file
skin_coordinates_MEAN_nii = image.load_img(simnibs_mesh_path + "/skin_coordinates_MEAN.nii.gz")
skin_coordiantes_MEAN_nii_data = skin_coordinates_MEAN_nii.get_fdata()


### Remove intermediate files
os.remove(simnibs_mesh_path + "/skin_coordinates.func.gii")
os.remove(simnibs_mesh_path + "/skull_coordinates.func.gii")
os.remove(simnibs_mesh_path + "/skin_normals.func.gii")
os.remove(simnibs_mesh_path + "/skull_normals.func.gii")
os.remove(simnibs_mesh_path + "/skin_coordinates_MEAN.func.gii")
os.remove(simnibs_mesh_path + "/skin_coordinates_MEAN.nii.gz")


#==============================================================================
# Create avoidance mask using ray tracing
#==============================================================================

# function for loading STL files
def loadSTL(filenameSTL):
    readerSTL = vtk.vtkSTLReader()
    readerSTL.SetFileName(filenameSTL)
    # 'update' the reader i.e. read the .stl file
    readerSTL.Update()

    polydata = readerSTL.GetOutput()

    # If there are no points in 'vtkPolyData' something went wrong
    if polydata.GetNumberOfPoints() == 0:
        raise ValueError(
            "No point data could be loaded from '" + filenameSTL)
        return None
    
    return polydata

# function for creating a metric file and eroding it
def create_metric_skin_eroded(vertex_values, metric_name):
    
    skin_values_nii_data_tmp = skin_coordiantes_MEAN_nii_data.copy()

    n = int(np.ceil(len(skin_coordinates)/len(skin_values_nii_data_tmp)))
    counter=0
    for i in np.arange(n):
        for j in np.arange(len(skin_values_nii_data_tmp)):
            try:
                skin_values_nii_data_tmp[j][i] = [vertex_values[(i*len(skin_values_nii_data_tmp)+j)]]
                
            except: None
        
    skin_values_nii = nib.nifti1.Nifti1Image(skin_values_nii_data_tmp, skin_coordinates_MEAN_nii.affine, header=skin_coordinates_MEAN_nii.header)
    
    skin_values_nii.to_filename(simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz")
    
    os.system("wb_command -metric-convert -from-nifti " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz" + " " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii")
    
    os.system("wb_command -metric-erode " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii" + " " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              "25 " + 
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii")


### create mask of sinuses using SimNIBS output
# create binary mask of final tissues file
os.system("fslmaths " + simnibs_mesh_path + "/final_tissues.nii.gz -bin " + simnibs_mesh_path + "/final_tissues_bin.nii.gz")
# fill holes (i.e. air cavities/sinuses) in binarzed mask
os.system("wb_command -volume-fill-holes " + simnibs_mesh_path + "/final_tissues_bin.nii.gz " + simnibs_mesh_path + "/final_tissues_bin_filled.nii.gz")
# create mask of holes (air cavities/sinuses) by subtracting the previously generated masks
os.system("fslmaths " + simnibs_mesh_path + "/final_tissues_bin_filled.nii.gz -sub " + simnibs_mesh_path + "/final_tissues_bin.nii.gz " + simnibs_mesh_path + "/final_tissues_air.nii.gz")

# create 3D stl/surface/mesh file from mask
os.system("mri_tessellate -n " + simnibs_mesh_path + "/final_tissues_air.nii.gz 1 " + simnibs_mesh_path + "/final_tissues_air")
os.system("mris_convert " + simnibs_mesh_path + "/final_tissues_air " + simnibs_mesh_path + "/final_tissues_air.surf.gii")
os.system("wb_command -surface-smoothing " + simnibs_mesh_path + "/final_tissues_air.surf.gii 0.5 10 " + simnibs_mesh_path + "/final_tissues_air.surf.gii")
os.system("mris_convert " + simnibs_mesh_path + "/final_tissues_air.surf.gii " + simnibs_mesh_path + "/final_tissues_air.stl")

# load mesh
mesh = loadSTL(simnibs_mesh_path + "/final_tissues_air.stl")

### find intersection between lines/rays going perpendicular to the head
### surface into the brain and the avoidance regions

obbTree = vtk.vtkOBBTree()
obbTree.SetDataSet(mesh)
obbTree.BuildLocator()

skin_air_intersection = []

for i in np.arange(len(skin_coordinates)):
    # starting point of line on skin
    pSource = skin_coordinates[i]
    # end point of line (4cm into the brain)
    pTarget = skin_coordinates[i] - 40 * skin_normals[i] # note: minus sign as normal points vector away from the head/brain
    
    pointsVTKintersection = vtk.vtkPoints()
    code = obbTree.IntersectWithLine(pSource, pTarget, pointsVTKintersection, None)

    pointsVTKIntersectionData = pointsVTKintersection.GetData()
    noPointsVTKIntersection = pointsVTKIntersectionData.GetNumberOfTuples()

    pointsIntersection = []
    for idx in range(noPointsVTKIntersection):
        _tup = pointsVTKIntersectionData.GetTuple3(idx)
        pointsIntersection.append(_tup)
        
    skin_air_intersection.append(pointsIntersection)

avoidance_mask = []
for i in np.arange(len(skin_air_intersection)):
    if len(skin_air_intersection[i]) > 0:
        avoidance_mask.append(0)
    else:
        avoidance_mask.append (1)
avoidance_mask = np.asarray(avoidance_mask)


# extract eyes from final tissue segmentation
simnibs_mesh_eyes = simnibs_mesh.crop_mesh(tags=[1006])
mesh_io.write_freesurfer_surface(simnibs_mesh_eyes, simnibs_mesh_path + "/eyes_freesurfer")
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/eyes_freesurfer" + " " +
          simnibs_mesh_path + "/eyes.stl")
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/eyes_freesurfer" + " " +
          simnibs_mesh_path + "/eyes.surf.gii")

# get coordinates
os.system('wb_command -surface-coordinates-to-metric ' +
           simnibs_mesh_path + "/eyes.surf.gii" + ' ' +
           simnibs_mesh_path + "/eyes_coordinates.func.gii")

eyes_coordinates = surface.load_surf_data(simnibs_mesh_path + "/eyes_coordinates.func.gii")
eyes_coordinates = np.array(eyes_coordinates, dtype=float)

# remove intermediate files
for f in glob.glob(simnibs_mesh_path + "/eyes*"):
    os.remove(f)

# separate left and right eye
x_coordinate_centers, _ = kmeans(eyes_coordinates[:,0], 2)
left_eye_coordinates = eyes_coordinates[eyes_coordinates[:,0] < (np.sum(x_coordinate_centers)/2)]
right_eye_coordinates = eyes_coordinates[eyes_coordinates[:,0] > (np.sum(x_coordinate_centers)/2)]

# center coordinates of eyes
left_eye_center = np.mean(left_eye_coordinates, axis=0)
right_eye_center = np.mean(right_eye_coordinates, axis=0)

# avoid vertices within 3 cm radius around the eye centers
avoidance_mask[np.linalg.norm((skin_coordinates-left_eye_center), axis=1) < 30] = 0
avoidance_mask[np.linalg.norm((skin_coordinates-right_eye_center), axis=1) < 30] = 0


# get left and right tragus coordinates (-1cm) from EEG fiducials
eeg_fiducials = pd.read_csv(simnibs_mesh_path + "/eeg_positions/Fiducials.csv", header=1)
LPA_coordinates = np.array(eeg_fiducials.iloc[0,1:4], dtype=np.float)
RPA_coordinates = np.array(eeg_fiducials.iloc[1,1:4], dtype=np.float)

LPA_coordinates[1] = LPA_coordinates[1] - 15 # move coordinate 1.5 cm posterior (to center of ear)
RPA_coordinates[1] = RPA_coordinates[1] - 15 # move coordinate 1.5 cm posterior (to center of ear)

# avoid vertices within 1.5 cm radius around the eye centers
avoidance_mask[np.linalg.norm((skin_coordinates-LPA_coordinates), axis=1) < 15] = 0
avoidance_mask[np.linalg.norm((skin_coordinates-RPA_coordinates), axis=1) < 15] = 0

create_metric_skin_eroded(avoidance_mask, "avoidance")

os.system("wb_command -metric-convert -to-nifti " +
          simnibs_mesh_path + "/skin_" + "avoidance" + "_" + target_roi_name + ".func.gii"+ " " +
          simnibs_mesh_path + "/skin_" + "avoidance" + "_" + target_roi_name + ".nii.gz")

# load dummy nifti file
avoidance_mask_nii = image.load_img(simnibs_mesh_path + "/skin_" + "avoidance" + "_" + target_roi_name + ".nii.gz")
avoidance_mask_nii_data = avoidance_mask_nii.get_fdata()
avoidance_mask_nii_data = avoidance_mask_nii_data.flatten('F')
avoidance_mask_nii_data = avoidance_mask_nii_data[0:len(skin_coordinates)]
avoidance_mask = avoidance_mask_nii_data.copy()


#==============================================================================
# Get center of gravity of traget ROI
#==============================================================================

target_roi = image.load_img(target_roi_filepath)

# get center of mass/gravity
target_roi_center = plotting.find_probabilistic_atlas_cut_coords([target_roi])[0]


#==============================================================================
# Get vectors describing the trajectory from each surface vertex to the center
# of the target ROI
#==============================================================================

# Skin
skin_target_vectors = []
for i in np.arange(len(skin_coordinates)):
    skin_target_vectors.append(skin_coordinates[i] - target_roi_center)
skin_target_vectors = np.asarray(skin_target_vectors)

# Skull
skull_target_vectors = []
for i in np.arange(len(skull_coordinates)):
    skull_target_vectors.append(skull_coordinates[i] - target_roi_center)
skull_target_vectors = np.asarray(skull_target_vectors)


#==============================================================================
# Compute 1) distance between each surface vertex and the target cetner and
# 2) angle between vectors from surface to target and normal vectors.#
#==============================================================================

### Define functions
def unit_vector(vector):
    """ Returns the unit vector of the vector. """
    return vector / np.linalg.norm(vector)

def angle_between(v1, v2):
    """ Returns the angle in radians between vectors 'v1' and 'v2' """
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))


### Compute distance
# Skin
skin_distances = []
for i in np.arange(len(skin_target_vectors)):
    skin_distances.append(np.linalg.norm(skin_target_vectors[i]))
skin_distances = np.abs(np.asarray(skin_distances))
skin_distances_masked = skin_distances.copy()
skin_distances_masked[skin_distances > max_distance] = 0

# Skull
skull_distances = []
for i in np.arange(len(skull_target_vectors)):
    skull_distances.append(np.linalg.norm(skull_target_vectors[i]))
skull_distances = np.abs(np.asarray(skull_distances))


### Compute angles
# Skin
skin_angles = []
for i in np.arange(len(skin_target_vectors)):
    skin_angles.append((math.degrees(angle_between(skin_target_vectors[i], skin_normals[i]))))
skin_angles = np.abs(np.asarray(skin_angles))
#skin_angles_masked = skin_angles.copy()
#skin_angles_masked[skin_angles > max_angle] = 0

# Skull
skull_angles = []
for i in np.arange(len(skull_target_vectors)):
    skull_angles.append((math.degrees(angle_between(skull_target_vectors[i], skull_normals[i]))))
skull_angles = np.abs(np.asarray(skull_angles))


#==============================================================================
# Combine information on distances and angles into a single optimization value
#==============================================================================

### standardize distances and angles
# Skin
skin_distances_std = (skin_distances - np.min(skin_distances))/(np.max(skin_distances) - np.min(skin_distances))
skin_angles_std = (skin_angles - np.min(skin_angles))/(np.max(skin_angles) - np.min(skin_angles))

# Skull
skull_distances_std = (skull_distances - np.min(skull_distances))/(np.max(skull_distances) - np.min(skull_distances))
skull_angles_std = (skull_angles - np.min(skull_angles))/(np.max(skull_angles) - np.min(skull_angles))

### compute element-wise product between distances and angles
# Skin
skin_distancesXangles = np.multiply(skin_distances_std, skin_angles_std)

# Skull
skull_distancesXangles = np.multiply(skull_distances_std, skull_angles_std)


#==============================================================================
# Compute "target overlap" through ray tracing
#==============================================================================

### create 3D model/surface/mesh (stl file) from target ROI mask
os.system('fslmaths ' + target_roi_filepath + ' -thr 0.25 -bin ' + target_roi_path + "/" + target_roi_name)
os.system("mri_tessellate -n " + target_roi_path + "/" + target_roi_name + ".nii.gz 1 " + target_roi_path + "/" + target_roi_name)
os.system("mris_convert " + target_roi_path + "/" + target_roi_name + " " + target_roi_path + "/" + target_roi_name + ".surf.gii")
os.system("wb_command -surface-smoothing " + target_roi_path + "/" + target_roi_name + ".surf.gii 0.5 10 " + target_roi_path + "/" + target_roi_name + ".surf.gii")
os.system("mris_convert " + target_roi_path + "/" + target_roi_name + ".surf.gii " + target_roi_path + "/" + target_roi_name + ".stl")

# load mesh
mesh = loadSTL(target_roi_path + "/" + target_roi_name + ".stl")


### Compute interesection of lines/rays going perpendicular to the head
### surface into the brain with the target ROI

obbTree = vtk.vtkOBBTree()
obbTree.SetDataSet(mesh)
obbTree.BuildLocator()

skin_target_intersection = []

for i in np.arange(len(skin_coordinates)):
    # starting point of line on skin
    pSource = skin_coordinates[i]
    # end point of line (20cm into the brain)
    pTarget = skin_coordinates[i] - 200 * skin_normals[i] # note: minus sign as normal points vector away from the head/brain
    
    pointsVTKintersection = vtk.vtkPoints()
    code = obbTree.IntersectWithLine(pSource, pTarget, pointsVTKintersection, None)

    pointsVTKIntersectionData = pointsVTKintersection.GetData()
    noPointsVTKIntersection = pointsVTKIntersectionData.GetNumberOfTuples()

    pointsIntersection = []
    for idx in range(noPointsVTKIntersection):
        _tup = pointsVTKIntersectionData.GetTuple3(idx)
        pointsIntersection.append(_tup)
        
    skin_target_intersection.append(pointsIntersection)

skin_target_intersection_values = []
for i in np.arange(len(skin_target_intersection)):
    if len(skin_target_intersection[i]) == 2:
        d = np.linalg.norm(np.asarray(skin_target_intersection[i][1])-np.asarray(skin_target_intersection[i][0]))
        skin_target_intersection_values.append (d)
    elif len(skin_target_intersection[i]) == 1:
        skin_target_intersection_values.append (0)
    # elif len(skin_target_intersection[i]) > 2:
    #     skin_target_intersection_values.append (100) # needs to be changed; just for testing
    elif len(skin_target_intersection[i]) == 3:
        d = np.linalg.norm(np.asarray(skin_target_intersection[i][1])-np.asarray(skin_target_intersection[i][0]))
        skin_target_intersection_values.append (d)
    elif len(skin_target_intersection[i]) == 4:
        d = (np.linalg.norm(np.asarray(skin_target_intersection[i][1])-np.asarray(skin_target_intersection[i][0]))+(np.linalg.norm(np.asarray(skin_target_intersection[i][3])-np.asarray(skin_target_intersection[i][2]))))
        skin_target_intersection_values.append (d)
    elif len(skin_target_intersection[i]) > 4:
        skin_target_intersection_values.append (np.nan)
    else:
        skin_target_intersection_values.append (0)
skin_target_intersection_values = np.asarray(skin_target_intersection_values)


#==============================================================================
# Compute angles between skin and skull normals
#==============================================================================

# create 3D stl/surface/mesh file from mask
os.system("mris_convert " + simnibs_mesh_path + "/skull.surf.gii " + simnibs_mesh_path + "/skull.stl")

# load mesh
mesh = loadSTL(simnibs_mesh_path + "/skull.stl")

### find intersection between lines/rays going perpendicular to the head
### surface into the brain and the skull

obbTree = vtk.vtkOBBTree()
obbTree.SetDataSet(mesh)
obbTree.BuildLocator()

skin_skull_intersection = []


for i in np.arange(len(skin_coordinates)):
    # starting point of line on skin
    pSource = skin_coordinates[i]
    # end point of line (4cm into the brain)
    pTarget = skin_coordinates[i] - 40 * skin_normals[i] # note: minus sign as normal points vector away from the head/brain
    
    pointsVTKintersection = vtk.vtkPoints()
    code = obbTree.IntersectWithLine(pSource, pTarget, pointsVTKintersection, None)

    pointsVTKIntersectionData = pointsVTKintersection.GetData()
    noPointsVTKIntersection = pointsVTKIntersectionData.GetNumberOfTuples()

    pointsIntersection = []
    for idx in range(noPointsVTKIntersection):
        _tup = pointsVTKIntersectionData.GetTuple3(idx)
        pointsIntersection.append(_tup)
        
    skin_skull_intersection.append(pointsIntersection)
    
    
indices_closest_skull_vertices = []

for i in np.arange(len(skin_coordinates)):
    
    try: 
        intersection_coordinate = skin_skull_intersection[i][0]
        ED_skull_list = np.linalg.norm((skull_coordinates - intersection_coordinate), axis=1)
        indices_closest_skull_vertices.append((np.argmin(ED_skull_list)))
    except:
        indices_closest_skull_vertices.append((np.nan))

indices_closest_skull_vertices = np.asarray(indices_closest_skull_vertices).astype(int)


skin_skull_angle_list = []

for i in np.arange(len(skin_coordinates)):
    
    try:
        skin_normal = skin_normals[i]
        skull_normal = skull_normals[indices_closest_skull_vertices[i]]
        
        skin_skull_angle = math.degrees(angle_between(skin_normal, skull_normal))
    
        skin_skull_angle_list.append(skin_skull_angle)
        
    except:
        skin_skull_angle_list.append(0)

skin_skull_angles = np.asarray(skin_skull_angle_list)
    

#==============================================================================
# "Smooth" resulting values with apperture size
#==============================================================================




#==============================================================================
# Mask resulting maps with avoidance mask
#==============================================================================

### Distances
# Skin
skin_distances_avoidance = skin_distances.copy()
skin_distances_avoidance[avoidance_mask == 0] = 0

skin_distances_masked_avoidance = skin_distances_masked.copy()
skin_distances_masked_avoidance[avoidance_mask == 0] = 0

### Angles
# Skin
skin_angles_avoidance = skin_angles.copy()
skin_angles_avoidance[avoidance_mask == 0] = 0

#skin_angles_masked_avoidance = skin_angles_masked.copy()
#skin_angles_masked_avoidance[avoidance_mask == 0] = 0

### Target ROI intersection
skin_target_intersection_avoidance = skin_target_intersection_values.copy()
skin_target_intersection_avoidance[avoidance_mask == 0] = 0

### Angles between skin and skull normals
skin_skull_angles_avoidance = skin_skull_angles.copy()
skin_skull_angles_avoidance[avoidance_mask == 0] = 0

#==============================================================================
# Create a metric file from the resulting values
#==============================================================================

### Fill dummy structure with values computed above

# Skin
def create_metric_skin(vertex_values, metric_name):
    
    skin_values_nii_data_tmp = skin_coordiantes_MEAN_nii_data.copy()

    n = int(np.ceil(len(skin_distancesXangles)/len(skin_values_nii_data_tmp)))
    counter=0
    for i in np.arange(n):
        for j in np.arange(len(skin_values_nii_data_tmp)):
            try:
                skin_values_nii_data_tmp[j][i] = [vertex_values[(i*len(skin_values_nii_data_tmp)+j)]]
                
            except: None
        
    skin_values_nii = nib.nifti1.Nifti1Image(skin_values_nii_data_tmp, skin_coordinates_MEAN_nii.affine, header=skin_coordinates_MEAN_nii.header)
    
    skin_values_nii.to_filename(simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz")
    
    os.system("wb_command -metric-convert -from-nifti " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz" + " " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii")


create_metric_skin(skin_distances, "distances")
create_metric_skin(skin_distances_avoidance, "distances+avoidance")
create_metric_skin(skin_distances_masked, "distances_max")
create_metric_skin(skin_distances_masked_avoidance, "distances+avoidance_max")
create_metric_skin(skin_angles, "angles")
create_metric_skin(skin_angles_avoidance, "angles+avoidance")
#create_metric_skin(skin_angles_masked, "angles")
#create_metric_skin(skin_angles_masked_avoidance, "angles+avoidance")
create_metric_skin(skin_target_intersection, "target_intersection")
create_metric_skin(skin_target_intersection_avoidance, "target_intersection+avoidance")
create_metric_skin(skin_skull_angles, "skin_skull_angles")
create_metric_skin(skin_skull_angles_avoidance, "skin_skull_angles+avoidance")


### remove intermediate files
for f in glob.glob(simnibs_mesh_path + "/skin*.nii.gz"):
    os.remove(f)
for f in glob.glob(simnibs_mesh_path + "/final_tissues_*"):
    os.remove(f)
for f in glob.glob(simnibs_mesh_path + "/" + target_roi_name + "*"):
    os.remove(f)
for f in glob.glob(simnibs_mesh_path + "/*.stl"):
    os.remove(f)
    
    
#=============================================================================
# Add structure information to .gii files
#=============================================================================

for f in glob.glob(simnibs_mesh_path + "/skin*.gii"):
    os.system("wb_command -set-structure " +
              f + " " +
              "CORTEX_LEFT" + ' ' +
              "-surface-type RECONSTRUCTION")
    
for f in glob.glob(simnibs_mesh_path + "/skull*.gii"):
    os.system("wb_command -set-structure " +
              f + " " +
              "CORTEX_RIGHT" + ' ' +
              "-surface-type RECONSTRUCTION")
    

#==============================================================================
# Create scene file
#==============================================================================

shutil.copy(scene_template_filepath, simnibs_mesh_path + '/scene_template_0.scene')

scene_variable_names = [
    'SKIN_SURFACE_FILENAME',
    'SKIN_SURFACE_FILEPATH',

    'SKULL_SURFACE_FILENAME',
    'SKULL_SURFACE_FILEPATH',

    'DISTANCES_FILENAME',
    'DISTANCES_FILEPATH',

    'INTERSECTION_FILENAME',
    'INTERSECTION_FILEPATH',

    'ANGLES_FILENAME',
    'ANGLES_FILEPATH',

    'ANGLES_SKIN_SKULL_FILENAME',
    'ANGLES_SKIN_SKULL_FILEPATH',

    'DISTANCES_MAX_FILENAME',
    'DISTANCES_MAX_FILEPATH',

    'T1_FILENAME',
    'T1_FILEPATH',

    'MASK_FILENAME',
    'MASK_FILEPATH']

scene_variable_values = [
    'skin.surf.gii',
    './skin.surf.gii',
    'skull.surf.gii',
    './skull.surf.gii',
    'skin_distances+avoidance_' + target_roi_name + '.func.gii',
    './skin_distances+avoidance_' + target_roi_name + '.func.gii',
    'skin_target_intersection+avoidance_' + target_roi_name + '.func.gii',
    './skin_target_intersection+avoidance_' + target_roi_name + '.func.gii',
    'skin_angles+avoidance_' + target_roi_name + '.func.gii',
    './skin_angles+avoidance_' + target_roi_name + '.func.gii',
    'skin_skin_skull_angles+avoidance_' + target_roi_name + '.func.gii',
    './skin_skin_skull_angles+avoidance_' + target_roi_name + '.func.gii',
    'skin_distances+avoidance_max_' + target_roi_name + '.func.gii',
    './skin_distances+avoidance_max_' + target_roi_name + '.func.gii',
    'T1.nii.gz',
    './T1.nii.gz',
    target_roi_filename,
    './' + target_roi_filename]

for i in np.arange(len(scene_variable_names)):
    
    os.system("cat " + simnibs_mesh_path + "/scene_template_" + str(i) + ".scene | awk -v awkvar=" + scene_variable_values[i] + " '{ gsub(/" + scene_variable_names[i] +"/, awkvar); print }' > " + simnibs_mesh_path + "/scene_template_" + str(i+1) + ".scene")
    
    os.remove(simnibs_mesh_path + "/scene_template_" + str(i) + ".scene")

shutil.copy(simnibs_mesh_path + "/scene_template_" + str(i+1) + ".scene", simnibs_mesh_path + '/scene_final_' + target_roi_name + '.scene')
os.remove(simnibs_mesh_path + "/scene_template_" + str(i+1) + ".scene")


#==============================================================================
#  Open everything in Connectome Workbench
#==============================================================================
    
# os.system('wb_view ' +
#           simnibs_mesh_path + "/skin.surf.gii" + " " +
#           simnibs_mesh_path + "/skin_distances+avoidance_" + target_roi_name + ".func.gii" + " " +
#           simnibs_mesh_path + "/skin_distances+avoidance_max_" + target_roi_name + ".func.gii" + " " +
#           simnibs_mesh_path + "/skin_target_intersection+avoidance_" + target_roi_name + ".func.gii" + " " +
#           simnibs_mesh_path + "/skin_angles+avoidance_" + target_roi_name + ".func.gii" + " " +
#           simnibs_mesh_path + "/skin_skin_skull_angles+avoidance_" + target_roi_name + ".func.gii" + " " +
#           simnibs_mesh_path + "/skull.surf.gii" + " " +
#           t1_filepath + " " +
#           target_roi_filepath + ' ' +
#           '&'
#           )

os.system('wb_view ' + simnibs_mesh_path + '/scene_final_' + target_roi_name + '.scene &')



# indices_closest_skull_vertices = []

# for i in np.arange(len(skin_coordinates)):
    
#     skin_coordinate = skin_coordinates[i]
        
#     ED_skull_list = np.linalg.norm((skull_coordinates - skin_coordinate), axis=1)

#     indices_closest_skull_vertices.append((np.argmin(ED_skull_list)))
#     print(np.argmin(ED_skull_list))
    
# indices_closest_skull_vertices = np.asarray(indices_closest_skull_vertices)


# skin_skull_angle_list = []

# for i in np.arange(len(skin_coordinates)):
    
#     skin_normal = skin_normals[i]
#     skull_normal = skull_normals[indices_closest_skull_vertices[i]]
    
#     skin_skull_angle = math.degrees(angle_between(skin_normal, skull_normal))

#     skin_skull_angle_list.append(skin_skull_angle)
    
# skin_skull_angles = np.asarray(skin_skull_angle_list)
    
# skin_skull_angles_avoidance = skin_skull_angles.copy()
# skin_skull_angles_avoidance[avoidance_mask == 0] = 0

# create_metric_skin(skin_skull_angles, "skin_skull_angles")
# create_metric_skin(skin_skull_angles_avoidance, "skin_skull_angles+avoidance")






# os.system('wb_command -metric-smoothing ' +
#           simnibs_mesh_path + "/skin.surf.gii " + 
#           simnibs_mesh_path + "/skin_target_intersection+avoidance_" + target_roi_name + ".func.gii" + " " +
#           "60 " +
#           simnibs_mesh_path + "/skin_target_intersection+avoidance_" + target_roi_name + "_s60.func.gii" + " " +
#           "-fwhm")

# os.system('wb_command -metric-smoothing ' +
#           simnibs_mesh_path + "/skin.surf.gii " + 
#           simnibs_mesh_path + "/skin_skin_skull_angles+avoidance_" + target_roi_name + ".func.gii" + " " +
#           "30 " +
#           simnibs_mesh_path + "/skin_skin_skull_angles+avoidance_" + target_roi_name + "_s30.func.gii" + " " +
#           "-fwhm")

# os.system('wb_command -metric-smoothing ' +
#           simnibs_mesh_path + "/skin.surf.gii " + 
#           simnibs_mesh_path + "/skin_skin_skull_angles+avoidance_" + target_roi_name + ".func.gii" + " " +
#           "10 " +
#           simnibs_mesh_path + "/skin_skin_skull_angles+avoidance_" + target_roi_name + "_s10.func.gii" + " " +
#           "-fwhm")



