#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar  1 12:04:29 2024

@author: maximilian
"""

import os
import glob
import numpy as np
import math
import nibabel as nib
from nilearn import image, plotting, surface
from simnibs import mesh_io
import vtk
import scipy.io
from scipy.io import savemat
from pyellipsoid import drawing
import h5py
from nibabel.gifti import GiftiImage, GiftiDataArray
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
from scipy.optimize import curve_fit


# Subject ID
subject_id = "Max"

# Path to T1 image (used for SimNIBS' charm)
t1_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/T1.nii.gz"

# Path to head mesh (.msh file) generated by SimNIBS' charm
simnibs_mesh_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max.msh"

# Name of and path to mask of target region of interest (in same space as T1
# image)
#target_roi_name = "Amygdala"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftAmygdala.nii.gz"
#target_roi_name = "NAcc"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftAccumbens.nii.gz"
#target_roi_name = "BF"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_JulichBrain_MPMAtlas_CH4_l_icbm.nii"
#target_roi_name = "sgACC"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-cortical_prob_SubcallosalCortex.nii.gz"
#target_roi_name = "Thalamus"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford-subcortical_prob_LeftThalamus.nii.gz"
#target_roi_name = "Thalamus_MedialDorsalNucleus_right"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_talairach_Right_Thalamus_Medial_Dorsal_Nucleus.nii.gz"
#target_roi_name = "Thalamus_NucleusReticulatusPolaris_bilateral_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_histthal_Nucleus_Reticulatus_Polaris.nii.gz"
#target_roi_name = "Thalamus_AnteriorNucleus_right"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_talairach_Right_Thalamus_Anterior_Nucleus.nii.gz"
target_roi_name = "LateralVentricle_right"
target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/Max_harvardoxford_subcortical_prob_Right_Lateral_Ventricle.nii.gz"
#target_roi_name = "Thalamus_MedialDorsalNucleus_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/sub-Max_talairach_Left_Thalamus_Medial_Dorsal_Nucleus.nii.gz"
#target_roi_name = "Thalamus_AnteriorNucleus_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/sub-Max_talairach_Left_Thalamus_Ventral_Anterior_Nucleus.nii.gz"
#target_roi_name = "LateralVentricle_left"
#target_roi_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/Max_WCM/m2m_Max/sub-Max_harvardoxford_subcortical_prob_Left_Lateral_Ventricle.nii.gz"



# Maximum focal depth of transducer (in mm)
# Note: Set to 1000 if you want a "whole-head" map of distances
max_distance = 76.6 # note: max. focal depth of CTX-500

transducer_3Dmodel_filepath = "/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/3D_models/TRANSDUCER-NEUROFUS-CTX-500-4_DEVICE.surf.gii"

#vertex_list = [44667] # Thalamus_MedialDorsalNucleus_right
#vertex_list = [27645] # Thalamus_NucleusReticulatusPolaris_bilateral, right
#vertex_list = [6969] # Thalamus_NucleusReticulatusPolaris_bilateral, right
#vertex_list = [6845] # Thalamus_NucleusReticulatusPolaris_bilateral, right
#vertex_list = [15067] # Thalamus_AnteriorNucleus_right
#vertex_list = [6051] # LateralVentricle_right

#vertex_list = [13479] # Thalamus_MedialDorsalNucleus_left
#vertex_list = [423] # Thalamus_NucleusReticulatusPolaris_bilateral, left
#vertex_list = [38164] # Thalamus_AnteriorNucleus_left
#vertex_list = [33298] # LateralVentricle_left

#vertex_list = [12968] # Thalamus_MedialDorsalNucleus_right
#vertex_list = [35881] # Thalamus_NucleusReticulatusPolaris_bilateral, right
#vertex_list = [8959] # Thalamus_AnteriorNucleus_right
vertex_list = [12973] # LateralVentricle_right

#=============================================================================
# Get relevant paths
#=============================================================================
t1_path = os.path.split(t1_filepath)[0]
simnibs_mesh_path = os.path.split(simnibs_mesh_filepath)[0]
target_roi_path = os.path.split(target_roi_filepath)[0]

# #=============================================================================
# # Convert SimNIBS mesh(es) to surface file(s)
# #=============================================================================

# ### Load SimNIBS mesh
# simnibs_mesh = mesh_io.read_msh(simnibs_mesh_filepath)

# ### Get tissue-specific meshes
# # Skin
# simnibs_mesh_skin = simnibs_mesh.crop_mesh(tags=1005)

# # Skull
# simnibs_mesh_skull = simnibs_mesh.crop_mesh(tags=[1007,1008]) # 1007 = compact bone, 1008 = spongy bone

# ### Save tissue-specific meshes as freesurfer surface file
# # Skin
# mesh_io.write_freesurfer_surface(simnibs_mesh_skin, simnibs_mesh_path + "/skin_freesurfer")

# # Skull
# mesh_io.write_freesurfer_surface(simnibs_mesh_skull, simnibs_mesh_path + "/skull_freesurfer")

# ### Convert to stl and surf.gii files
# # Skin
# os.system("mris_convert" + " " +
#           simnibs_mesh_path + "/skin_freesurfer" + " " +
#           simnibs_mesh_path + "/skin.stl")

# os.system("mris_convert" + " " +
#           simnibs_mesh_path + "/skin_freesurfer" + " " +
#           simnibs_mesh_path + "/skin.surf.gii")

# # Skull
# os.system("mris_convert" + " " +
#           simnibs_mesh_path + "/skull_freesurfer" + " " +
#           simnibs_mesh_path + "/skull.stl")
          
# os.system("mris_convert" + " " +
#           simnibs_mesh_path + "/skull_freesurfer" + " " +
#           simnibs_mesh_path + "/skull.surf.gii")

# ### Remove intermediate files
# os.remove(simnibs_mesh_path + "/skin_freesurfer")
# os.remove(simnibs_mesh_path + "/skull_freesurfer")


#==============================================================================
# Get metrics from surfaces
#==============================================================================

### vertex coordinates
# Skin
os.system("wb_command -surface-coordinates-to-metric " +
            simnibs_mesh_path + "/skin.surf.gii" + " " +
            simnibs_mesh_path + "/skin_coordinates.func.gii")

skin_coordinates = surface.load_surf_data(simnibs_mesh_path + "/skin_coordinates.func.gii")
skin_coordinates = np.array(skin_coordinates, dtype=float)

# Skull
os.system("wb_command -surface-coordinates-to-metric " +
            simnibs_mesh_path + "/skull.surf.gii" + " " +
            simnibs_mesh_path + "/skull_coordinates.func.gii")

skull_coordinates = surface.load_surf_data(simnibs_mesh_path + "/skull_coordinates.func.gii")
skull_coordinates = np.array(skull_coordinates, dtype=float)


### surface/vertex normals
# Skin
os.system("wb_command -surface-normals " +
            simnibs_mesh_path + "/skin.surf.gii" + " " +
            simnibs_mesh_path + "/skin_normals.func.gii")

skin_normals = surface.load_surf_data(simnibs_mesh_path + "/skin_normals.func.gii")
skin_normals = np.array(skin_normals, dtype=float)


# Skull
os.system("wb_command -surface-normals " +
            simnibs_mesh_path + "/skull.surf.gii" + " " +
            simnibs_mesh_path + "/skull_normals.func.gii")

skull_normals = surface.load_surf_data(simnibs_mesh_path + "/skull_normals.func.gii")
skull_normals = np.array(skull_normals, dtype=float)


### Remove intermediate files
os.remove(simnibs_mesh_path + "/skin_coordinates.func.gii")
os.remove(simnibs_mesh_path + "/skull_coordinates.func.gii")
os.remove(simnibs_mesh_path + "/skin_normals.func.gii")
os.remove(simnibs_mesh_path + "/skull_normals.func.gii")


for vertex_index in vertex_list:

    #==============================================================================
    # Get coordinates and normal vector for vetrex of interest
    #==============================================================================
    
    vertex_coordinates = skin_coordinates[vertex_index]
    vertex_normal_vector = skin_normals[vertex_index]
    
    
    #==============================================================================
    # Create transducer position matrix (first in Localite coordinate system)
    #==============================================================================
    
    offset = 10.82 # mm (CTX-500/CTX-545)
    additional_offset = 3 # mm
    
    position_matrix_Localite = np.zeros([4,4]) # dummy matrix
    position_matrix_Localite[3,3] = 1
    
    tranducer_center_coordinates = vertex_coordinates + ((offset + additional_offset) * vertex_normal_vector)
    position_matrix_Localite[0:3,3] = np.transpose(tranducer_center_coordinates)
    
    x_vector = -vertex_normal_vector # negative normal vector "into the head"
    x_vector /= np.linalg.norm(x_vector) # compute unit vector
    position_matrix_Localite[0:3,0] = x_vector 
    
    # compute vector orhtogonal to x vector
    y_vector = np.random.randn(3) # random vector
    y_vector -= y_vector.dot(x_vector) * x_vector # make it orthogonal to x vector
    y_vector /= np.linalg.norm(y_vector) # normalize
    position_matrix_Localite[0:3,1] = y_vector 
    
    # compute vector orhtogonal to x and y vector
    z_vector = np.cross(x_vector, y_vector)
    z_vector /= np.linalg.norm(z_vector) # normalize
    position_matrix_Localite[0:3,2] = z_vector 
    
    # Save
    savemat(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "_Localite.mat", {'position_matrix': position_matrix_Localite})
    np.savetxt(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "Localite.txt", position_matrix_Localite)
    
    
    #==============================================================================
    # Convert to k-Plan coordinate system
    #==============================================================================
    
    position_matrix_kPlan = position_matrix_Localite.copy()
    
    position_matrix_kPlan[0:3,0] = -position_matrix_Localite[0:3,1] # x(k-Plan) = -y(Localite)
    position_matrix_kPlan[0:3,1] = position_matrix_Localite[0:3,2] # y(k-Plan) = z(k-Plan)
    position_matrix_kPlan[0:3,2] = -position_matrix_Localite[0:3,0]  # z(k-Plan) = -x(Localite)
    
    # Save
    #savemat(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".mat", {'position_matrix': position_matrix_kPlan})
    np.savetxt(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".txt", position_matrix_kPlan)
    
    # Convert center coordinates from mm (Localite) to m (k-Plan)
    position_matrix_kPlan_final = position_matrix_kPlan.copy()
    
    position_matrix_kPlan_final[0:3,3] = position_matrix_kPlan[0:3,3]/1000
    
    # Save
    savemat(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "_kPlan.mat", {'position_matrix': position_matrix_kPlan_final})
    np.savetxt(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "_kPlan.txt", position_matrix_kPlan_final)

    # transform transducer file
    os.system("wb_command -surface-apply-affine " +
              transducer_3Dmodel_filepath + " " +
              simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".txt" + " " +
              simnibs_mesh_path + "/transducer_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii")
    
    os.system("wb_command -set-structure " +
               simnibs_mesh_path + "/transducer_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
               "CEREBELLUM -surface-type RECONSTRUCTION")
    

    
    # Create "fake" XML structure with matrix values
    xml = '    <Element index="0" selected="true" type="InstrumentMarker">\n\
            <InstrumentMarker additionalInformation="" alwaysVisible="false"\n\
                color="#00ff00" description="transducer_position_' + target_roi_name + '_vtx' + str(vertex_index) + '" locked="false" set="true" uid="0">\n\
                <Matrix4D data00="' + str(round(position_matrix_Localite[0,0],6)) + '" data01="' + str(round(position_matrix_Localite[0,1],6)) + '" data02="' + str(round(position_matrix_Localite[0,2],6)) + '"\n\
                    data03="' + str(round(position_matrix_Localite[0,3],6)) + '" data10="' + str(round(position_matrix_Localite[1,0],6)) + '" data11="' + str(round(position_matrix_Localite[1,1],6)) + '"\n\
                    data12="' + str(round(position_matrix_Localite[1,2],6)) + '" data13="' + str(round(position_matrix_Localite[1,3],6)) + '" data20="' + str(round(position_matrix_Localite[2,0],6)) + '"\n\
                    data21="' + str(round(position_matrix_Localite[2,1],6)) + '" data22="' + str(round(position_matrix_Localite[2,2],6)) + '" data23="' + str(round(position_matrix_Localite[2,3],6)) + '" data30="0.0"\n\
                    data31="0.0" data32="0.0" data33="1.0"/>\n\
            </InstrumentMarker>\n\
        </Element>\n\
    '

    # Save/append "fake" XML structure in text file
    with open(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "_Localite_XML.txt", "a") as f:
        f.write(xml)


    # Localite -> Slicer
    position_matrix_Slicer = position_matrix_kPlan.copy()
    position_matrix_Slicer[0:3,0] = -position_matrix_Localite[0:3,2] # x = -y
    position_matrix_Slicer[0:3,1] = -position_matrix_Localite[0:3,1] # y = -z
    position_matrix_Slicer[0:3,2] = -position_matrix_Localite[0:3,0] # z = -x
    
    savemat(simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "_Slicer.mat", {'position_matrix': position_matrix_Slicer})


    test_matrix = position_matrix_kPlan.copy()
    test_matrix[0:3,3] = [0,0,0]
    np.savetxt(simnibs_mesh_path + "/test_matrix.txt", test_matrix)


#==============================================================================
# Create transducer positon file for k-Plan
#==============================================================================

    position_matrix_filepath  = simnibs_mesh_path + "/position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + "_kPlan.mat"
    output_name = target_roi_name + "_vtx" + str(vertex_index)
    
    def position_transform_4kplan(subject_id, output_name, position_matrix_filepath):
        # Generate output variables
    
        # Create output filename
        fPath, fName = os.path.split(position_matrix_filepath)
        output_filepath = os.path.join(fPath, f"sub-{subject_id}_{output_name}.kps")
        
        # Load position matrix
        mat_contents = scipy.io.loadmat(position_matrix_filepath)
        position_matrix = mat_contents["position_matrix"]
        position_matrix = np.transpose(position_matrix)
        position_label = "Localite transducer position"
        
        # Reshape position matrix to (1, 4, 4)
        position_matrix = position_matrix.reshape((1, 4, 4))
        
        # Save transform matrices to HDF5 file
        with h5py.File(output_filepath, "w") as f:
            dset = f.create_dataset("/1/position_transform", (1, 4, 4), dtype="float32")
            dset[:] = position_matrix.astype("float32")
            
            # Write attributes with ASCII encoding and specifying string lengths
            f["/1"].attrs.create("transform_label", np.string_(position_label))
            f.attrs.create("application_name", np.string_("k-Plan"))
            f.attrs.create("file_type", np.string_("k-Plan Transducer Position"))
            f.attrs.create("number_transforms", np.array([1], dtype=np.uint64))
            
    
    position_transform_4kplan(subject_id, output_name, position_matrix_filepath)

#==============================================================================
# Compute "target overlap" through ray tracing
#==============================================================================

    # function for loading STL files
    def loadSTL(filenameSTL):
        readerSTL = vtk.vtkSTLReader()
        readerSTL.SetFileName(filenameSTL)
        # "update" the reader i.e. read the .stl file
        readerSTL.Update()

        polydata = readerSTL.GetOutput()

        # If there are no points in 'vtkPolyData' something went wrong
        if polydata.GetNumberOfPoints() == 0:
            raise ValueError(
                "No point data could be loaded from '" + filenameSTL)
            return None
        
        return polydata

    ### create 3D model/surface/mesh (stl file) from target ROI mask
    os.system("fslmaths " + target_roi_filepath + " -thr 0.25 -bin " + target_roi_path + "/" + target_roi_name)
    os.system("mri_tessellate -n " + target_roi_path + "/" + target_roi_name + ".nii.gz 1 " + target_roi_path + "/" + target_roi_name)
    os.system("mris_convert " + target_roi_path + "/" + target_roi_name + " " + target_roi_path + "/" + target_roi_name + ".surf.gii")
    os.system("wb_command -surface-smoothing " + target_roi_path + "/" + target_roi_name + ".surf.gii 0.5 10 " + target_roi_path + "/" + target_roi_name + ".surf.gii")
    os.system("mris_convert " + target_roi_path + "/" + target_roi_name + ".surf.gii " + target_roi_path + "/" + target_roi_name + ".stl")
    
    # load mesh
    mesh = loadSTL(target_roi_path + "/" + target_roi_name + ".stl")
    
    
    ### Compute interesection of lines/rays going perpendicular to the head
    ### surface into the brain with the target ROI
    
    obbTree = vtk.vtkOBBTree()
    obbTree.SetDataSet(mesh)
    obbTree.BuildLocator()
    
    skin_target_intersection = [vertex_index]
    
    
    # starting point of line on skin
    pSource = skin_coordinates[vertex_index]
    # end point of line (20cm into the brain)
    pTarget = skin_coordinates[vertex_index] - 200 * skin_normals[vertex_index] # note: minus sign as normal points vector away from the head/brain
    
    pointsVTKintersection = vtk.vtkPoints()
    code = obbTree.IntersectWithLine(pSource, pTarget, pointsVTKintersection, None)

    pointsVTKIntersectionData = pointsVTKintersection.GetData()
    noPointsVTKIntersection = pointsVTKIntersectionData.GetNumberOfTuples()

    pointsIntersection = []
    for idx in range(noPointsVTKIntersection):
        _tup = pointsVTKIntersectionData.GetTuple3(idx)
        pointsIntersection.append(_tup)
        
    skin_target_intersection = pointsIntersection
    
    skin_target_intersection_center = (np.asarray(skin_target_intersection[0]) + np.asarray(skin_target_intersection[1]))/2


#==============================================================================
# Compute requires focal distance and corresponding FLHM
#==============================================================================

    # Focal distance and corresponding FLHM values (both in mm)
    focal_distance = [33.1, 34.7, 36.8, 39.3, 42.4, 46.2, 50.8, 56.0, 61.8, 68.5, 76.6]
    flhm = [8.4, 9.3, 10.3, 11.6, 13.5, 16.1, 19.2, 22.8, 26.3, 30.2, 34.5]
    
    data={'Focal Distance': focal_distance, 'FLHM': flhm}
    
    df = pd.DataFrame(data)
    
    # Fit function to measured values
    def cubic(x, a, b, c, d):
        return a + b*x + c*(x**2) + d*(x**3)
    
    pars, cov = curve_fit(f=cubic, xdata=df["Focal Distance"], ydata=df["FLHM"], p0=[0, 0, 0, 0], bounds=[-np.inf, np.inf])
    
    def calculate_FLHM(focus_distance):
        FLHM = pars[0] + pars[1] * focus_distance + pars[2] * focus_distance**2 + pars[3] * focus_distance**3
        return FLHM
    
    
    # Compute distance from between head surface and center of target
    # intersection, i.e. required focal distance
    focal_distance = np.linalg.norm(skin_coordinates[vertex_index] - skin_target_intersection_center) + 3 # add 3 mm additional distance
    
    if focal_distance > max_distance:
        focal_distance = max_distance
    
    # Compute expected FLHM
    FLHM = calculate_FLHM(focal_distance)    
    

#==============================================================================
# Create ellipsoid (surface)
#==============================================================================

    # Desired ellipsoid dimensions in mm
    desired_length = FLHM  # along the major axis
    desired_width = 5    # along the minor axis
    
    # load T1 image
    t1_image = nib.load(t1_filepath)
    t1_image_data = t1_image.get_fdata()
    
    # get voxel dimensions of T1 image
    pixdim = t1_image.header["pixdim"][1:4]
    
    # Image dimensions and grid spacing in mm
    image_shape = t1_image_data.shape
    grid_spacing = pixdim[0]
    
    # Calculate scaling factors to fit the desired dimensions
    # We assume the major axis is along the z-axis
    scale_z = desired_length / (image_shape[2] * grid_spacing)
    scale_xy = desired_width / (image_shape[0] * grid_spacing)
    
    # Calculate radii based on the scaling factors
    a = image_shape[0] * grid_spacing * scale_xy / 2
    b = image_shape[1] * grid_spacing * scale_xy / 2
    c = image_shape[2] * grid_spacing * scale_z / 2
    
    # Create a grid of points
    phi = np.linspace(0, 2 * np.pi, 50)
    theta = np.linspace(0, np.pi, 50)
    phi, theta = np.meshgrid(phi, theta)
    
    # Parametric equations for the ellipsoid
    x = a * np.sin(theta) * np.cos(phi)
    y = b * np.sin(theta) * np.sin(phi)
    z = c * np.cos(theta)
    
    # Flatten the arrays and stack them as a (N, 3) array of points
    points = np.vstack((x.flatten(), y.flatten(), z.flatten())).T.astype(np.float32)
    
    # Create faces using the points
    faces = []
    num_rows, num_cols = x.shape
    
    for i in range(num_rows - 1):
        for j in range(num_cols - 1):
            faces.append([i * num_cols + j,
                          i * num_cols + (j + 1),
                          (i + 1) * num_cols + j])
            faces.append([(i + 1) * num_cols + j,
                          i * num_cols + (j + 1),
                          (i + 1) * num_cols + (j + 1)])
    
    faces = np.array(faces, dtype=np.int32)
    
    # Create GIFTI data arrays
    coord_array = GiftiDataArray(data=points, intent="NIFTI_INTENT_POINTSET")
    face_array = GiftiDataArray(data=faces, intent="NIFTI_INTENT_TRIANGLE")
    
    # Create a GIFTI image
    gii = GiftiImage(darrays=[coord_array, face_array])
    
    # Save the GIFTI image
    nib.save(gii, t1_path + "/ellipsoid.gii")
    
    # tranform .gii to .surf.gii file
    os.system("mris_convert " +
              t1_path + "/ellipsoid.gii" + " " + 
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii")
    
    os.remove(t1_path + "/ellipsoid.gii")
    
    # create and save transform for focus
    focus_transform = position_matrix_kPlan.copy()
    focus_transform[0:3,3] = skin_target_intersection_center
    np.savetxt(simnibs_mesh_path + "/focus_position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".txt", focus_transform)

    # apply transform to focus (.surf.gii file) and set structure
    os.system("wb_command -surface-apply-affine " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
              simnibs_mesh_path + "/focus_position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".txt" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii")
    
    os.system("wb_command -set-structure " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
              "CORTEX_RIGHT" + " " +
              "-surface-type RECONSTRUCTION")
    
    
#==============================================================================
# Create ellipsoid (volume)
#==============================================================================

    # create surface ellipsoid with smaller dimensions
    # Desired ellipsoid dimensions in mm
    desired_length = desired_length - 1  # along the major axis
    desired_width = desired_width - 1   # along the minor axis
    
    # load T1 image
    t1_image = nib.load(t1_filepath)
    t1_image_data = t1_image.get_fdata()
    
    # get voxel dimensions of T1 image
    pixdim = t1_image.header["pixdim"][1:4]
    
    # Image dimensions and grid spacing in mm
    image_shape = t1_image_data.shape
    grid_spacing = pixdim[0]
    
    # Calculate scaling factors to fit the desired dimensions
    # We assume the major axis is along the z-axis
    scale_z = desired_length / (image_shape[2] * grid_spacing)
    scale_xy = desired_width / (image_shape[0] * grid_spacing)
    
    # Calculate radii based on the scaling factors
    a = image_shape[0] * grid_spacing * scale_xy / 2
    b = image_shape[1] * grid_spacing * scale_xy / 2
    c = image_shape[2] * grid_spacing * scale_z / 2
    
    # Create a grid of points
    phi = np.linspace(0, 2 * np.pi, 50)
    theta = np.linspace(0, np.pi, 50)
    phi, theta = np.meshgrid(phi, theta)
    
    # Parametric equations for the ellipsoid
    x = a * np.sin(theta) * np.cos(phi)
    y = b * np.sin(theta) * np.sin(phi)
    z = c * np.cos(theta)
    
    # Flatten the arrays and stack them as a (N, 3) array of points
    points = np.vstack((x.flatten(), y.flatten(), z.flatten())).T.astype(np.float32)
    
    # Create faces using the points
    faces = []
    num_rows, num_cols = x.shape
    
    for i in range(num_rows - 1):
        for j in range(num_cols - 1):
            faces.append([i * num_cols + j,
                          i * num_cols + (j + 1),
                          (i + 1) * num_cols + j])
            faces.append([(i + 1) * num_cols + j,
                          i * num_cols + (j + 1),
                          (i + 1) * num_cols + (j + 1)])
    
    faces = np.array(faces, dtype=np.int32)
    
    # Create GIFTI data arrays
    coord_array = GiftiDataArray(data=points, intent="NIFTI_INTENT_POINTSET")
    face_array = GiftiDataArray(data=faces, intent="NIFTI_INTENT_TRIANGLE")
    
    # Create a GIFTI image
    gii = GiftiImage(darrays=[coord_array, face_array])
    
    # Save the GIFTI image
    nib.save(gii, t1_path + "/ellipsoid.gii")
    
    # tranform .gii to .surf.gii file
    os.system("mris_convert " +
              t1_path + "/ellipsoid.gii" + " " + 
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + "_small.surf.gii")
    
    os.remove(t1_path + "/ellipsoid.gii")
    
    # create and save transform for focus
    focus_transform = position_matrix_kPlan.copy()
    focus_transform[0:3,3] = skin_target_intersection_center
    np.savetxt(simnibs_mesh_path + "/focus_position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".txt", focus_transform)

    # apply transform to focus (.surf.gii file) and set structure
    os.system("wb_command -surface-apply-affine " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + "_small.surf.gii" + " " +
              simnibs_mesh_path + "/focus_position_matrix_" + target_roi_name + "_vtx" + str(vertex_index) + ".txt" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + "_small.surf.gii")
    
    os.system("wb_command -set-structure " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + "_small.surf.gii" + " " +
              "CORTEX_RIGHT" + " " +
              "-surface-type RECONSTRUCTION")
    

    # create metric from surface
    os.system("wb_command -surface-coordinates-to-metric " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".func.gii")
    
    # map metric to volume
    os.system("wb_command -metric-to-volume-mapping " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".func.gii" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
              t1_filepath + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz" + " " +
              "-ribbon-constrained " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + "_small.surf.gii" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii")
    
    # fill holes in volume
    os.system("wb_command -volume-fill-holes " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz")
    
    # extract first image from volume and binarize
    ellipsoid = image.load_img(t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz")
    ellipsoid_data = ellipsoid.get_fdata()
    ellipsoid_data = ellipsoid_data[:,:,:,0]
    ellipsoid_data[ellipsoid_data > 0] = 1
    ellipsoid_nii_image = nib.Nifti1Image(ellipsoid_data, ellipsoid.affine)
    ellipsoid_nii_image.to_filename(t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz")
    
    # # erode volume
    # os.system("fslmaths " +
    #           t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz" + " " +
    #           "-ero " +
    #           t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz")
    
    # remove intermediate files
    os.remove(t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".func.gii")
    os.remove(t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + "_small.surf.gii")


#==============================================================================
# Visualize results
#==============================================================================

    os.system("wb_view " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              simnibs_mesh_path + "/skin_distances+avoidance_" + target_roi_name + ".func.gii" + " " +
              simnibs_mesh_path + "/skin_target_intersection+avoidance_" + target_roi_name + ".func.gii" + " " +
              simnibs_mesh_path + "/skin_angles+avoidance_" + target_roi_name + ".func.gii" + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
              simnibs_mesh_path + "/transducer_" + target_roi_name + "_vtx" + str(vertex_index) + ".surf.gii" + " " +
              t1_filepath + " " +
              target_roi_filepath + " " +
              t1_path + "/ellipsoid_" + target_roi_name + "_vtx" + str(vertex_index) + ".nii.gz" + " " +
              "&"
              )
    



# # dimensions of focus
# len_x = 30
# len_y = 5
# len_z = 5

# # define target coordinate
# target_coord = skin_target_intersection_center

# # Define an image shape, axis order is: Z, Y, X
# image_shape = t1_image_data.shape

# # Define an ellipsoid, axis order is: X, Y, Z
# # Note: X = Z, Y = Y, Z = X
# ell_center = (np.round(target_coord[2]/pixdim[0]), np.round(target_coord[1]/pixdim[1]), np.round(target_coord[0]/pixdim[2]))
# ell_radii = (len_x/2/pixdim[0], len_y/2/pixdim[1], len_z/2/pixdim[2])

# # Define your input vector
# u = x_vector

# # Define the unit vectors for the coordinate axes
# x_axis = np.array([1, 0, 0])
# y_axis = np.array([0, 1, 0])
# z_axis = np.array([0, 0, 1])

# # Calculate the magnitudes of the vectors
# mag_u = np.linalg.norm(u)
# mag_x_axis = np.linalg.norm(x_axis)
# mag_y_axis = np.linalg.norm(y_axis)
# mag_z_axis = np.linalg.norm(z_axis)

# # Compute the dot products
# dot_x = np.dot(u, x_axis)
# dot_y = np.dot(u, y_axis)
# dot_z = np.dot(u, z_axis)

# # Calculate the cosine of the angles
# cos_x_angle = dot_x / (mag_u * mag_x_axis)
# cos_y_angle = dot_y / (mag_u * mag_y_axis)
# cos_z_angle = dot_z / (mag_u * mag_z_axis)

# # Calculate the angles using arccos
# x_angle = np.arccos(cos_x_angle)
# y_angle = np.arccos(cos_y_angle)
# z_angle = np.arccos(cos_z_angle)

# # Convert the angles from radians to degrees
# x_angle_degrees = np.degrees(x_angle)
# y_angle_degrees = np.degrees(y_angle)
# z_angle_degrees = np.degrees(z_angle)

# print("Angle with x-axis:", x_angle_degrees, "degrees")
# print("Angle with y-axis:", y_angle_degrees, "degrees")
# print("Angle with z-axis:", z_angle_degrees, "degrees")


# ell_angles = np.deg2rad([x_angle_degrees,y_angle_degrees,z_angle_degrees]) # Order of rotations is X, Y, Z
# ell_angles = [0,0,0]

# # Draw a 3D binary image containing the ellipsoid
# ell_image = drawing.make_ellipsoid_image(image_shape, ell_center, ell_radii, ell_angles)

# # create new nifti image
# ell_nii_image = nib.Nifti1Image(ell_image, t1_image.affine)
# ell_nii_image.to_filename(t1_path + '/ellipsoid.nii.gz') 




    









