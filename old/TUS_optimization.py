#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Sep 16 14:46:30 2023

@author: Maximilian Lueckel, mlueckel@uni-mainz.de
"""
#=============================================================================
#=============================================================================
# Generate useful metrics for planning of TUS transducer placement
#=============================================================================
#=============================================================================
# Input:
# - Head mesh (.msh file) generated by SimNIBS' charm pipeline
# - Mask (.nii/.nii.gz file) of target region (in same space as T1 image used
#   for SimNIBS' charm)
# - Maximum focal depth of TUS transducer (in mm)
# - Maximum allowed angle for tilting of TUS transducer (in degree)
#-----------------------------------------------------------------------------
# Outputs:
# - 3D head model in surf.gii format
# - 3D model of target region
# - Metric files (func.gii format)
#=============================================================================
#=============================================================================
# Requirements:
# Python
# - numpy
# - math
# - nibabel
# - nilearn
# - simnibs
# - vtk
# SimNIBS (incl. simnibs_python)
# Conenctome Workbench
#=============================================================================
# Specify variables
#=============================================================================

# Path to head mesh (.msh file) generated by SimNIBS' charm
simnibs_mesh_filepath = '/path/to/m2m_{subject}/{subject}.msh'

# Name of and path to mask of target region
target_roi_name = 'NAcc'
target_roi_filepath = '/path/to/NAcc_mask.nii.gz'

# Maximum focal depth of transducer (in mm)
max_distance = 76.6 # max. focal depth of CTX-500

# Maximum allowed angle for tilting of TUS transducer (in degree)
max_angle = 10

import os
import numpy as np
import math
import nibabel as nib
from nilearn import image, plotting, surface
from simnibs import mesh_io
import vtk

#simnibs_mesh_filepath = '/media/maximilian/Elements1/vmPFC_Project/data/study_data_processed/SimNIBS/sub-035/m2m_sub-035/sub-035.msh'
#target_roi_filepath = '/media/maximilian/Elements1/vmPFC_Project/data/study_data_processed/SimNIBS/sub-035/m2m_sub-035/Dorina_JulichBrain_MPMAtlas_CH4_l_icbm.nii'

simnibs_mesh_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/MNI_template/m2m_T1_kPlan/T1_kPlan.msh'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/MNI_template/JulichBrain_MPMAtlas_CH4_l_icbm_kPlan.nii'
#target_roi_name = 'BF'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/MNI_template/harvardoxford-cortical_prob_SubcallosalCortex_kPlan.nii.gz'
#target_roi_name = 'sgACC'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/MNI_template/harvardoxford-subcortical_prob_LeftThalamus_kPlan.nii.gz'
#target_roi_name = 'Thalamus'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/MNI_template/harvardoxford-cortical_prob_FrontalMedialCortex_kPlan.nii.gz'
#target_roi_name = 'vmPFC'
target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/TUS_vmPFC/TUS_optimization/MNI_template/m2m_T1_kPlan/kPlan_harvardoxford-subcortical_prob_LeftAccumbens.nii.gz'
target_roi_name = 'NAcc'


#simnibs_mesh_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/vmPFC_Project/data/study_data_processed/SimNIBS/sub-Suhas/m2m_sub-Suhas/sub-Suhas.msh'
#target_roi_filepath = '/media/maximilian/e4713b47-344e-4ac6-85dd-b6769e0cbfa8/vmPFC_Project/data/study_data_processed/SimNIBS/sub-Suhas/m2m_sub-Suhas/Suhas_MNI_res-epi_label-VTASN_mask.nii.gz'


simnibs_mesh_path = os.path.split(simnibs_mesh_filepath)[0]
target_roi_path = os.path.split(target_roi_filepath)[0]


max_distance = 1000 #76.6 # in mm [max. focal depth of CTX-545]
max_angle = 360 # in degrees





#=============================================================================
# Convert SimNIBS mesh(es) to surface file(s)
#=============================================================================

### Load SimNIBS mesh
simnibs_mesh = mesh_io.read_msh(simnibs_mesh_filepath)

### Get tissue-specific meshes
# Skin
simnibs_mesh_skin = simnibs_mesh.crop_mesh(tags=1005)

# Skull
simnibs_mesh_skull = simnibs_mesh.crop_mesh(tags=[1007,1008]) # 1007 = compact bone, 1008 = spongy bone

### Save tissue-specific meshes as freesurfer surface file
# Skin
mesh_io.write_freesurfer_surface(simnibs_mesh_skin, simnibs_mesh_path + "/skin_freesurfer")

# Skull
mesh_io.write_freesurfer_surface(simnibs_mesh_skull, simnibs_mesh_path + "/skull_freesurfer")

### Convert to stl and surf.gii files
# Skin
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skin_freesurfer" + " " +
          simnibs_mesh_path + "/skin.stl")

os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skin_freesurfer" + " " +
          simnibs_mesh_path + "/skin.surf.gii")

# Skull
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skull_freesurfer" + " " +
          simnibs_mesh_path + "/skull.stl")
          
os.system("mris_convert" + " " +
          simnibs_mesh_path + "/skull_freesurfer" + " " +
          simnibs_mesh_path + "/skull.surf.gii")

### Remove intermediate files
os.remove(simnibs_mesh_path + "/skin_freesurfer")
os.remove(simnibs_mesh_path + "/skull_freesurfer")


#==============================================================================
# Get metrics from surfaces
#==============================================================================

### vertex coordinates
# Skin
os.system('wb_command -surface-coordinates-to-metric ' +
           simnibs_mesh_path + "/skin.surf.gii" + ' ' +
           simnibs_mesh_path + "/skin_coordinates.func.gii")

skin_coordinates = surface.load_surf_data(simnibs_mesh_path + "/skin_coordinates.func.gii")

# Skull
os.system('wb_command -surface-coordinates-to-metric ' +
           simnibs_mesh_path + "/skull.surf.gii" + ' ' +
           simnibs_mesh_path + "/skull_coordinates.func.gii")

skull_coordinates = surface.load_surf_data(simnibs_mesh_path + "/skull_coordinates.func.gii")


### surface/vertex normals
# Skin
os.system('wb_command -surface-normals ' +
           simnibs_mesh_path + "/skin.surf.gii" + ' ' +
           simnibs_mesh_path + "/skin_normals.func.gii")

skin_normals = surface.load_surf_data(simnibs_mesh_path + "/skin_normals.func.gii")


# Skull
os.system('wb_command -surface-normals ' +
           simnibs_mesh_path + "/skull.surf.gii" + ' ' +
           simnibs_mesh_path + "/skull_normals.func.gii")

skull_normals = surface.load_surf_data(simnibs_mesh_path + "/skull_normals.func.gii")


#==============================================================================
# Create dummy metric and nifti file
#==============================================================================

# create dummy metric file (mean of vertex coordiantes)
os.system("wb_command -metric-reduce " +
          simnibs_mesh_path + "/skin_coordinates.func.gii" + " " +
          "MEAN " + 
          simnibs_mesh_path + "/skin_coordinates_MEAN.func.gii")

# convert dummy metric file to dummy nifti file
os.system("wb_command -metric-convert -to-nifti " +
          simnibs_mesh_path + "/skin_coordinates_MEAN.func.gii" + " " +
          simnibs_mesh_path + "/skin_coordinates_MEAN.nii.gz")

# load dummy nifti file
skin_coordinates_MEAN_nii = image.load_img(simnibs_mesh_path + "/skin_coordinates_MEAN.nii.gz")
skin_coordiantes_MEAN_nii_data = skin_coordinates_MEAN_nii.get_fdata()


#==============================================================================
# Create avoidance mask using ray tracing
#==============================================================================

# function for loading STL files
def loadSTL(filenameSTL):
    readerSTL = vtk.vtkSTLReader()
    readerSTL.SetFileName(filenameSTL)
    # 'update' the reader i.e. read the .stl file
    readerSTL.Update()

    polydata = readerSTL.GetOutput()

    # If there are no points in 'vtkPolyData' something went wrong
    if polydata.GetNumberOfPoints() == 0:
        raise ValueError(
            "No point data could be loaded from '" + filenameSTL)
        return None
    
    return polydata

# function for creating a metric file and eroding it
def create_metric_skin_eroded(vertex_values, metric_name):
    
    skin_values_nii_data_tmp = skin_coordiantes_MEAN_nii_data.copy()

    n = int(np.ceil(len(skin_coordinates)/len(skin_values_nii_data_tmp)))
    counter=0
    for i in np.arange(n):
        for j in np.arange(len(skin_values_nii_data_tmp)):
            try:
                skin_values_nii_data_tmp[j][i] = [vertex_values[(i*len(skin_values_nii_data_tmp)+j)]]
                
            except: None
        
    skin_values_nii = nib.nifti1.Nifti1Image(skin_values_nii_data_tmp, skin_coordinates_MEAN_nii.affine, header=skin_coordinates_MEAN_nii.header)
    
    skin_values_nii.to_filename(simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz")
    
    os.system("wb_command -metric-convert -from-nifti " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz" + " " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii")
    
    os.system("wb_command -metric-erode " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii" + " " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              "25 " + 
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii")


### create mask of sinuses using SimNIBS output
# create binary mask of final tissues file
os.system("fslmaths " + simnibs_mesh_path + "/final_tissues.nii.gz -bin " + simnibs_mesh_path + "/final_tissues_bin.nii.gz")
# fill holes (i.e. air cavities/sinuses) in binarzed mask
os.system("wb_command -volume-fill-holes " + simnibs_mesh_path + "/final_tissues_bin.nii.gz " + simnibs_mesh_path + "/final_tissues_bin_filled.nii.gz")
# create mask of holes (air cavities/sinuses) by subtracting the previously generated masks
os.system("fslmaths " + simnibs_mesh_path + "/final_tissues_bin_filled.nii.gz -sub " + simnibs_mesh_path + "/final_tissues_bin.nii.gz " + simnibs_mesh_path + "/final_tissues_air.nii.gz")

# create 3D stl/surface/mesh file from mask
os.system("mri_tessellate -n " + simnibs_mesh_path + "/final_tissues_air.nii.gz 1 " + simnibs_mesh_path + "/final_tissues_air")
os.system("mris_convert " + simnibs_mesh_path + "/final_tissues_air " + simnibs_mesh_path + "/final_tissues_air.surf.gii")
os.system("wb_command -surface-smoothing " + simnibs_mesh_path + "/final_tissues_air.surf.gii 0.5 10 " + simnibs_mesh_path + "/final_tissues_air.surf.gii")
os.system("mris_convert " + simnibs_mesh_path + "/final_tissues_air.surf.gii " + simnibs_mesh_path + "/final_tissues_air.stl")

# load mesh
mesh = loadSTL(simnibs_mesh_path + "/final_tissues_air.stl")

### find intersection between lines/rays going perpendicular to the head
### surface into the brain and the avoidance regions

obbTree = vtk.vtkOBBTree()
obbTree.SetDataSet(mesh)
obbTree.BuildLocator()

skin_air_intersection = []

for i in np.arange(len(skin_coordinates)):
    # starting point of line on skin
    pSource = skin_coordinates[i]
    # end point of line (4cm into the brain)
    pTarget = skin_coordinates[i] - 40 * skin_normals[i] # note: minus sign as normal points vector away from the head/brain
    
    pointsVTKintersection = vtk.vtkPoints()
    code = obbTree.IntersectWithLine(pSource, pTarget, pointsVTKintersection, None)

    pointsVTKIntersectionData = pointsVTKintersection.GetData()
    noPointsVTKIntersection = pointsVTKIntersectionData.GetNumberOfTuples()

    pointsIntersection = []
    for idx in range(noPointsVTKIntersection):
        _tup = pointsVTKIntersectionData.GetTuple3(idx)
        pointsIntersection.append(_tup)
        
    skin_air_intersection.append(pointsIntersection)

avoidance_mask = []
for i in np.arange(len(skin_air_intersection)):
    if len(skin_air_intersection[i]) > 0:
        avoidance_mask.append(0)
    else:
        avoidance_mask.append (1)
avoidance_mask = np.asarray(avoidance_mask)


create_metric_skin_eroded(avoidance_mask, "avoidance")

os.system("wb_command -metric-convert -to-nifti " +
          simnibs_mesh_path + "/skin_" + "avoidance" + "_" + target_roi_name + ".func.gii"+ " " +
          simnibs_mesh_path + "/skin_" + "avoidance" + "_" + target_roi_name + ".nii.gz")

# load dummy nifti file
avoidance_mask_nii = image.load_img(simnibs_mesh_path + "/skin_" + "avoidance" + "_" + target_roi_name + ".nii.gz")
avoidance_mask_nii_data = avoidance_mask_nii.get_fdata()
avoidance_mask_nii_data = avoidance_mask_nii_data.flatten('F')
avoidance_mask_nii_data = avoidance_mask_nii_data[0:len(skin_coordinates)]
avoidance_mask = avoidance_mask_nii_data.copy()


#==============================================================================
# Get center of gravity of traget ROI
#==============================================================================

target_roi = image.load_img(target_roi_filepath)

# get center of mass/gravity
target_roi_center = plotting.find_probabilistic_atlas_cut_coords([target_roi])[0]


#==============================================================================
# Get vectors describing the trajectory from each surface vertex to the center
# of the target ROI
#==============================================================================

# Skin
skin_target_vectors = []
for i in np.arange(len(skin_coordinates)):
    skin_target_vectors.append(skin_coordinates[i] - target_roi_center)
skin_target_vectors = np.asarray(skin_target_vectors)

# Skull
skull_target_vectors = []
for i in np.arange(len(skull_coordinates)):
    skull_target_vectors.append(skull_coordinates[i] - target_roi_center)
skull_target_vectors = np.asarray(skull_target_vectors)


#==============================================================================
# Compute 1) distance between each surface vertex and the target cetner and
# 2) angle between vectors from surface to target and normal vectors.#
#==============================================================================

### Define functions
def unit_vector(vector):
    """ Returns the unit vector of the vector. """
    return vector / np.linalg.norm(vector)

def angle_between(v1, v2):
    """ Returns the angle in radians between vectors 'v1' and 'v2' """
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))


### Compute distance
# Skin
skin_distances = []
for i in np.arange(len(skin_target_vectors)):
    skin_distances.append(np.linalg.norm(skin_target_vectors[i]))
skin_distances = np.abs(np.asarray(skin_distances))
skin_distances_masked = skin_distances.copy()
skin_distances_masked[skin_distances > max_distance] = 0

# Skull
skull_distances = []
for i in np.arange(len(skull_target_vectors)):
    skull_distances.append(np.linalg.norm(skull_target_vectors[i]))
skull_distances = np.abs(np.asarray(skull_distances))


### Compute angles
# Skin
skin_angles = []
for i in np.arange(len(skin_target_vectors)):
    skin_angles.append((math.degrees(angle_between(skin_target_vectors[i], skin_normals[i]))))
skin_angles = np.abs(np.asarray(skin_angles))
skin_angles_masked = skin_angles.copy()
skin_angles_masked[skin_angles > max_angle] = 0

# Skull
skull_angles = []
for i in np.arange(len(skull_target_vectors)):
    skull_angles.append((math.degrees(angle_between(skull_target_vectors[i], skull_normals[i]))))
skull_angles = np.abs(np.asarray(skull_angles))


#==============================================================================
# Combine information on distances and angles into a single optimization value
#==============================================================================

### standardize distances and angles
# Skin
skin_distances_std = (skin_distances - np.min(skin_distances))/(np.max(skin_distances) - np.min(skin_distances))
skin_angles_std = (skin_angles - np.min(skin_angles))/(np.max(skin_angles) - np.min(skin_angles))

# Skull
skull_distances_std = (skull_distances - np.min(skull_distances))/(np.max(skull_distances) - np.min(skull_distances))
skull_angles_std = (skull_angles - np.min(skull_angles))/(np.max(skull_angles) - np.min(skull_angles))

### compute element-wise product between distances and angles
# Skin
skin_distancesXangles = np.multiply(skin_distances_std, skin_angles_std)

# Skull
skull_distancesXangles = np.multiply(skull_distances_std, skull_angles_std)


#==============================================================================
# Compute "target overlap" through ray tracing
#==============================================================================

### create 3D model/surface/mesh (stl file) from target ROI mask
os.system('fslmaths ' + target_roi_filepath + ' -thr 0.25 -bin ' + target_roi_path + "/" + target_roi_name)
os.system("mri_tessellate -n " + target_roi_path + "/" + target_roi_name + ".nii.gz 1 " + target_roi_path + "/" + target_roi_name)
os.system("mris_convert " + target_roi_path + "/" + target_roi_name + " " + target_roi_path + "/" + target_roi_name + ".surf.gii")
os.system("wb_command -surface-smoothing " + target_roi_path + "/" + target_roi_name + ".surf.gii 0.5 10 " + target_roi_path + "/" + target_roi_name + ".surf.gii")
os.system("mris_convert " + target_roi_path + "/" + target_roi_name + ".surf.gii " + target_roi_path + "/" + target_roi_name + ".stl")

# load mesh
mesh = loadSTL(target_roi_path + "/" + target_roi_name + ".stl")


### Compute interesection of lines/rays going perpendicular to the head
### surface into the brain with the target ROI

obbTree = vtk.vtkOBBTree()
obbTree.SetDataSet(mesh)
obbTree.BuildLocator()

skin_target_intersection = []

for i in np.arange(len(skin_coordinates)):
    # starting point of line on skin
    pSource = skin_coordinates[i]
    # end point of line (20cm into the brain)
    pTarget = skin_coordinates[i] - 200 * skin_normals[i] # note: minus sign as normal points vector away from the head/brain
    
    pointsVTKintersection = vtk.vtkPoints()
    code = obbTree.IntersectWithLine(pSource, pTarget, pointsVTKintersection, None)

    pointsVTKIntersectionData = pointsVTKintersection.GetData()
    noPointsVTKIntersection = pointsVTKIntersectionData.GetNumberOfTuples()

    pointsIntersection = []
    for idx in range(noPointsVTKIntersection):
        _tup = pointsVTKIntersectionData.GetTuple3(idx)
        pointsIntersection.append(_tup)
        
    skin_target_intersection.append(pointsIntersection)

skin_target_intersection_values = []
for i in np.arange(len(skin_target_intersection)):
    if len(skin_target_intersection[i]) == 2:
        d = np.linalg.norm(np.asarray(skin_target_intersection[i][1])-np.asarray(skin_target_intersection[i][0]))
        skin_target_intersection_values.append (d)
    elif len(skin_target_intersection[i]) == 1:
        skin_target_intersection_values.append (0)
    # elif len(skin_target_intersection[i]) > 2:
    #     skin_target_intersection_values.append (100) # needs to be changed; just for testing
    elif len(skin_target_intersection[i]) == 3:
        d = np.linalg.norm(np.asarray(skin_target_intersection[i][1])-np.asarray(skin_target_intersection[i][0]))
        skin_target_intersection_values.append (d)
    elif len(skin_target_intersection[i]) == 4:
        d = (np.linalg.norm(np.asarray(skin_target_intersection[i][1])-np.asarray(skin_target_intersection[i][0]))+(np.linalg.norm(np.asarray(skin_target_intersection[i][3])-np.asarray(skin_target_intersection[i][2]))))
        skin_target_intersection_values.append (d)
    elif len(skin_target_intersection[i]) > 4:
        skin_target_intersection_values.append (np.nan)
    else:
        skin_target_intersection_values.append (0)
skin_target_intersection_values = np.asarray(skin_target_intersection_values)


#==============================================================================
# Mask resulting values with avoidance mask
#==============================================================================

### Distances
# Skin
skin_distances_masked_avoidance = skin_distances_masked.copy()
skin_distances_masked_avoidance[avoidance_mask == 0] = 0

### Angles
# Skin
skin_angles_masked_avoidance = skin_angles_masked.copy()
skin_angles_masked_avoidance[avoidance_mask == 0] = 0

### Target ROI intersection
skin_target_intersection_avoidance = skin_target_intersection_values.copy()
skin_target_intersection_avoidance[avoidance_mask == 0] = 0

#==============================================================================
# Create a metric file from the resulting values
#==============================================================================

### Fill dummy structure with values computed above

# Skin
def create_metric_skin(vertex_values, metric_name):
    
    skin_values_nii_data_tmp = skin_coordiantes_MEAN_nii_data.copy()

    n = int(np.ceil(len(skin_distancesXangles)/len(skin_values_nii_data_tmp)))
    counter=0
    for i in np.arange(n):
        for j in np.arange(len(skin_values_nii_data_tmp)):
            try:
                skin_values_nii_data_tmp[j][i] = [vertex_values[(i*len(skin_values_nii_data_tmp)+j)]]
                
            except: None
        
    skin_values_nii = nib.nifti1.Nifti1Image(skin_values_nii_data_tmp, skin_coordinates_MEAN_nii.affine, header=skin_coordinates_MEAN_nii.header)
    
    skin_values_nii.to_filename(simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz")
    
    os.system("wb_command -metric-convert -from-nifti " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".nii.gz" + " " +
              simnibs_mesh_path + "/skin.surf.gii" + " " +
              simnibs_mesh_path + "/skin_" + metric_name + "_" + target_roi_name + ".func.gii")


create_metric_skin(skin_distances_masked, "distances")
create_metric_skin(skin_distances_masked_avoidance, "distances+avoidance")
create_metric_skin(skin_angles_masked, "angles")
create_metric_skin(skin_angles_masked_avoidance, "angles+avoidance")
create_metric_skin(skin_target_intersection, "target_intersection")
create_metric_skin(skin_target_intersection_avoidance, "target_intersection+avoidance")

# ### create and load a dummy nifti file
# # Skin
# os.system("wb_command -metric-convert -to-nifti " +
#           simnibs_mesh_path + "/skin_coordinates.func.gii" + " " +
#           simnibs_mesh_path + "/skin_coordinates.nii.gz")

# skin_coordinates_nii = image.load_img(simnibs_mesh_path + "/skin_coordinates.nii.gz")
# skin_coordiantes_nii_data = skin_coordinates_nii.get_data()


# # Skull
# os.system("wb_command -metric-convert -to-nifti " +
#           simnibs_mesh_path + "/skull_coordinates.func.gii" + " " +
#           simnibs_mesh_path + "/skull_coordinates.nii.gz")

# skull_coordinates_nii = image.load_img(simnibs_mesh_path + "/skull_coordinates.nii.gz")
# skull_coordiantes_nii_data = skull_coordinates_nii.get_data()


# ### Fill dummy structure with values computed above
# # Skin
# skin_values_nii_data_tmp = skin_coordiantes_nii_data.copy()

# n = int(np.ceil(len(skin_distancesXangles)/len(skin_values_nii_data_tmp)))
# counter=0
# for i in np.arange(n):
#     for j in np.arange(len(skin_values_nii_data_tmp)):
#         try:
#             skin_values_nii_data_tmp[j][i] = [skin_distancesXangles[(i*len(skin_values_nii_data_tmp)+j)],
#                                               skin_distances[(i*len(skin_values_nii_data_tmp)+j)],
#                                               skin_angles[(i*len(skin_values_nii_data_tmp)+j)]]
            
#         except: None
    
# skin_values_nii = nib.nifti1.Nifti1Image(skin_values_nii_data_tmp, skin_coordinates_nii.affine, header=skin_coordinates_nii.header)

# skin_values_nii.to_filename(simnibs_mesh_path + "/skin_distances_angles_" + target_roi_name + ".nii.gz")

# os.system("wb_command -metric-convert -from-nifti " +
#           simnibs_mesh_path + "/skin_distances_angles_" + target_roi_name + ".nii.gz" + " " +
#           simnibs_mesh_path + "/skin.surf.gii" + " " +
#           simnibs_mesh_path + "/skin_distances_angles_" + target_roi_name + ".func.gii")


# # Skull
# skull_values_nii_data_tmp = skull_coordiantes_nii_data.copy()

# n = int(np.ceil(len(skull_distancesXangles)/len(skull_values_nii_data_tmp)))
# counter=0
# for i in np.arange(n):
#     for j in np.arange(len(skull_values_nii_data_tmp)):
#         try:
#             skull_values_nii_data_tmp[j][i] = [skull_distancesXangles[(i*len(skull_values_nii_data_tmp)+j)],
#                                                skull_distances[(i*len(skull_values_nii_data_tmp)+j)],
#                                                skull_angles[(i*len(skull_values_nii_data_tmp)+j)]]
            
#         except: None
    
# skull_values_nii = nib.nifti1.Nifti1Image(skull_values_nii_data_tmp, skull_coordinates_nii.affine, header=skull_coordinates_nii.header)

# skull_values_nii.to_filename(simnibs_mesh_path + "/skull_distances_angles_" + target_roi_name + ".nii.gz")

# os.system("wb_command -metric-convert -from-nifti " +
#           simnibs_mesh_path + "/skull_distances_angles_" + target_roi_name + ".nii.gz" + " " +
#           simnibs_mesh_path + "/skull.surf.gii" + " " +
#           simnibs_mesh_path + "/skull_distances_angles_" + target_roi_name + ".func.gii")




    





